---
layout: post
date: 2024-12-25-11:19:32
---

‎2024‎年‎12‎月‎25‎日，‏‎11:19:32
2025年1月2日


有很多不同的证明工具，各自的用法和机制都不尽相同。

这里主要简单地谈论 Coq，它基于类型论。

为什么 coq 代码看起来很晦涩
- 它是从结论往前写，这和平时写数学证明的习惯不一致。解决方案是正向写，写引理。
- 隐含的上下文，省略参数。所以可以单步执行，或者显示地写出来参数和中间见过。
- 命令基于类型论，而不是常见的逻辑运算。所以可以把针对逻辑运算符的指令当作固定的写法。
- 命令模式和函数模式，两套写法很分割。都可以，选择简单的写法。


处于传统和应用场合的原因，Coq代码仍保留传统的书写风格。一些数学的的则 lean 则鼓励正向写出每一步结果，尽管会比较啰嗦。


最基本的式 `->` 运算，有两条最基本的运算。
1. `A, A->B => B` 。这是消去规则
2. `P|-Q => |-P->Q`。这是构造规则。


在 coq 中对应用到 `intro` 和 `apply` 两条命令，分别对应不同规则。这里`指令`有引号，防止歧义。

从程序语言的角度一切看并不复杂，apply对应函数调用，intro对应lambda语句。实现一个函数即证明了这个函数能够成立，写出程序即完成了证明。

## 关于证明


以加法的交换律和结合律为例，代码来自标准库。

```Coq

```


关于上面出现的其他代码，属于固定的模板框架，按照字面意思理解就可以了。

而对于谓词，则可以使用

为了抽象，可以自定义谓词，则有对应的构造函数和解构函数。

其他用到的命令都是针对自定义类型，常用的逻辑连接词都是这样在系统中定义。可以通过调用构造函数来构造。

同样的是逻辑运算符，和 -> 是类似也有引入和消去规则，在 Coq 中只是用到的命令不同。

## 基本指令

| 符号        | 出现在待证目标                  | 出现在已知假设 H                               |
| --------- | ------------------------ | --------------------------------------- |
| ->        | **intro**                | **apply H**                             |
| $\forall$ | intro                    | apply H                                 |
| ~         | intro,                   | apply H                                 |
| 结论        |                          | **exact H**, assumption, trivial, auto, |
| false     |                          | absurd, contradiction                   |
| $\land$   | split, constructor       | elim H, case H, destruct H              |
| $\lor$    | left, right, constructor | elim H, case H, destruct H              |
| $\exists$ | exists, constructor      | elim H, case H, destruct H              |
| =         | **reflexivity**,         | rewrite H, rewrite <- H                 |
| <>        | discriminate             |                                         |
| P(X)      | constructor，apply C      | elim H, case H, destruct H              |
| P(X) 递归定义 |                          | elim H, intuition                       |
| 定义/定理     | simp, unfold             |                                         |

说明
- 对于一个嵌套的表达式，以上表格只看表达式的最外层的符号。
- 由于是向后证明**想要**证明什么**及要**证明什么，导致看上去针对目标的指令的作用是反的，即从输出到输入。
- 指令默认是改变目标，但是也可以作用于前提，使用in参数比如 `apply H in H`。
- 处于版本迭代和实现差异的原因，可能同一功能有多个指令。看代码的时候可能都能看到，自己写的话固定一种就行。也还有很多类似于语法糖的指令，可以很容易从字面意思和上下文上来理解。
- apply一个构造函数，等价于 `constructor`，也在上书表格中有很多方便使用的别名。
- 正向证明可以使用 **assert** `assert (H: e) (or assert (e) as H):`显示写出中间结果。可以在传入参数的时候，以函数调用的形式执行apply。
- 对于等式还有等式的性质 symmetry, transitivity, ring
	- 以及谓词的相等性 f_equal, injection, inversion, discriminate（用于`<>`）
- 经典逻辑需要手动开启排中律，从而使用相应的反证法、以及分类讨论。






## 程序证明

要证明针对所有输入性质成立，那么就使用数学归纳法。
对于命令式语言，利用最弱前置条件。


## 数学证明


目前 AI 的发展更希望正向显示的书写风格，一步一步写出中间结果，这和人类手稿的习惯类似。中间过程可以用搜索算法补充。

lean4 有数学相关的标准库，工具也以数学问题为导向。

## 附录

程序正确性。

类型系统。不需要了解。


LCF System




参考资料
- [Theorem Proving in Lean 4 - Theorem Proving in Lean 4](https://lean-lang.org/theorem_proving_in_lean4/)
- [Mathematics in Lean — Mathematics in Lean 0.1 documentation](https://leanprover-community.github.io/mathematics_in_lean/index.html)
- Coq in a Hurry
- Isabelle
- 

<!--



## 草稿


不需要
正向 pose (proof_of_B := A_implies_B proof_of_A).

逆向 `refine (A_implies_B _). `
`assert (witness : ((x :: rest) <> nil)).`
- injection... as...: reason by injectivity on equalities between values of inductively defined types
    
- discriminate: reason by disjointness of constructors on equalities between values of inductively defined types
- ~~因为结论只有一个，所以可以省略目标，而使用前提时还需要指定针对哪个前提。~~
- ~~注意 apply 经常省略参数，~~

	- absurd, specialize, cut,

-->
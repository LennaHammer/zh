
## Ubuntu

```bash
sudo apt update
sudo apt install nginx
sudo apt install mysql-server
sudo apt install redis-server
sudo apt install docker.io
sudo apt install docker-compose
sudo apt install jdk
```

用 docker 可以启动常见服务。注意数据系统有需要保存的文件。
```bash
sudo docker run -d -p 80:80 nginx
```
## Maven

## Spring

https://spring.io/quickstart
https://spring.io/guides
https://start.spring.io/ 通常选 Spring Boot DevTools，Spring Web，


注意 spring 项目的目录结构，这个不需要记住，直接复制一个已有项目就可以开始了。从一个完整的项目来看各个功能是如何工作的，而不要去拼装组件。




功能
Web
用户登录，用户权限。
数据库
日志
缓存，尽量少读写数据库。
队列，消息队列，任务队列。
搜索 es。
数据字典，菜单目录。
工作流。审批模块。
报表，数据可视化。
表单。
抢票，预约。
分布式，保证一致性，分布式锁 Redisson



## Spring Boot

初始化可以用，需要选择的包有。

```java
package com.example.demo;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@SpringBootApplication
@RestController
public class DemoApplication {
    public static void main(String[] args) {
      SpringApplication.run(DemoApplication.class, args);
    }
    @GetMapping("/hello")
    public String hello(@RequestParam(value = "name", defaultValue = "World") String name) {
      return String.format("Hello %s!", name);
    }
}
```

代替一部门 xml。

用来初始化组价，以及调用。
```java
@Bean Receiver receiver() { return new Receiver(); }
```

用 @Autowired 或者用构造参数。Spring会自动安排初始化顺序。

## Spring MVC

Controller

```java
package com.example.helloworld.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

// 标记为 REST 风格控制器（返回数据而非页面）
@RestController
public class HelloController {

    // 映射 GET 请求，路径为 "/hello"
    @GetMapping("/hello")
    public String helloWorld() {
        // 返回响应内容
        return "Hello, Spring Boot!";
    }

    // 扩展：带参数的请求（可选）
    @GetMapping("/hello/{name}")
    public String helloWithName(String name) {
        return "Hello, " + name + "! Welcome to Spring Boot!";
    }
}
```




## 数据库

### mysql


- 如果要远程访问的户，需要先创建用户，比如 `CREATE USER 'testuser'@'localhost' IDENTIFIED BY 'Test@123456';`
- root 只在本地用 `sudo mysql` 使用。
- mysql 查询元数据。
- 大家都知道mysql的默认数据库隔离级别嘛？ 是的，就是RR，但是呢，为什么阿里这些互联网大厂，把mysql的数据隔离级别设置为RC呢？
- 写代码前可以先用命令行或图形界面（比如 heidiSQL）尝试。
- 先创建库，再创建表。

spring 使用数据库
### mybatis

占位符区别（#{} vs ${}）
#{}：参数预编译（推荐），会将参数替换为 ?，防止 SQL 注入，如 WHERE id = ?。
${}：字符串拼接，直接替换参数（有注入风险），适合表名、排序字段等动态参数，如 ORDER BY ${field}。
结果映射（ResultMap）当数据库字段与实体类属性无法通过驼峰转换匹配时（如数据库 u_name → 实体 username），需用 ResultMap 手动映射：
当数据库字段与实体类属性无法通过驼峰转换匹配时（如数据库 u_name → 实体 username），需用 ResultMap 手动映射：
xml



```yaml
spring:
  # 数据库配置
  datasource:
    url: jdbc:mysql://localhost:3306/mybatis_demo?useSSL=false&serverTimezone=Asia/Shanghai&allowPublicKeyRetrieval=true
    username: root # 你的MySQL用户名
    password: 123456 # 你的MySQL密码
    driver-class-name: com.mysql.cj.jdbc.Driver # MySQL 8.x驱动类名

mybatis:
  # 1. 映射文件（XML）的位置（若用注解则可省略）
  mapper-locations: classpath:mybatis/mappers/*.xml
  # 2. 实体类别名包扫描（简化XML中resultType/parameterType的类名）
  type-aliases-package: com.example.mybatis.entity
  # 3. 开启驼峰命名自动转换（数据库字段 user_name → Java属性 userName）
  configuration:
    map-underscore-to-camel-case: true
    # 可选：打印SQL日志（开发环境调试用）
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
```


这个有工具从数据表生成。
```java
package com.example.mybatis.entity;

import lombok.Data; // Lombok注解，自动生成getter/setter/toString等

@Data // 等价于 @Getter + @Setter + @ToString + @EqualsAndHashCode + @NoArgsConstructor
public class User {
    private Long id;       // 对应数据库 id
    private String userName; // 对应数据库 user_name（驼峰转换生效）
    private Integer age;   // 对应数据库 age
    private String email;  // 对应数据库 email
}
```


用 xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" 
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- namespace必须与Mapper接口全类名一致 -->
<mapper namespace="com.example.mybatis.mapper.UserXmlMapper">

    <!-- 1. 新增用户 -->
    <insert id="insert" parameterType="User" 
            useGeneratedKeys="true" keyProperty="id" keyColumn="id">
        INSERT INTO user (user_name, age, email) 
        VALUES (#{userName}, #{age}, #{email})
    </insert>

    <!-- 2. 根据ID查询（resultType指定返回类型，因配置了type-aliases-package，可直接写类名User） -->
    <select id="selectById" parameterType="java.lang.Long" resultType="User">
        SELECT * FROM user WHERE id = #{id}
    </select>

    <!-- 3. 查询所有 -->
    <select id="selectAll" resultType="User">
        SELECT * FROM user
    </select>

    <!-- 4. 更新用户 -->
    <update id="update" parameterType="User">
        UPDATE user 
        SET user_name = #{userName}, age = #{age}, email = #{email} 
        WHERE id = #{id}
    </update>

    <!-- 5. 删除用户 -->
    <delete id="deleteById" parameterType="java.lang.Long">
        DELETE FROM user WHERE id = #{id}
    </delete>

</mapper>
```

也可以用注解，目前还是用 xml 更多一些。


### 日志
日志 log slf4j
### 队列
队列 queue rabbitTemplate.convertAndSend
### 缓存
缓存 cache 使用 ConcurrentHashMap 或者 redis。可以通过注解使用，也可以手动直接调用具体的实现。

需要持久化和消息确认，防止消息丢失。




## nginx

用来转发给应用服务器

```nginx
http {
    server {
        listen 80;
        server_name example.com www.example.com;
        location / { ... }
        location /static/ { ... }
    }
}
```


## 容器化


docker
kubernetes


## 用户权限


## 数据字典


## 分布式

丰富的锁类型
    
除了基础的可重入锁，还支持：

- 公平锁（`redissonClient.getFairLock("key")`）：按请求顺序获取锁，避免饥饿；
- 读写锁（`redissonClient.getReadWriteLock("key")`）：读共享、写独占，适合读多写少场景；
- 红锁（`RedissonRedLock`）：基于 Redlock 算法，适配多 Redis 实例，提升锁的可靠性。
    
Redisson 是 Redis 的 Java 客户端框架，封装了分布式锁等高级功能，比手写 Redis 命令更稳定、易用。

## Linux
zsh
tmux












### git

git add code.c
git commit -m "xxx"
git rebase

git gui




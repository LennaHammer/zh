



### Python 包安装


```bash
pip3 install filelock
pip3 install torch torchvision
pip3 install pandas dask numpy sympy

pip3 install nltk spacy
pip3 install sqlalchemy
pip3 install requests_html beautifulsoup4 lxml
pip3 install 
pip3 install 
pip3 install regexp

pip3 install pillow
pip3 install networkx
```

### python 爬虫
- 用 request 或者 requests_html
- 请求头
- cookie 会变化，通常用来防止爬虫。属于 http 协议，不需要 js 支持。这个 request 支持，用 session。
- bs4 用 lxml 能解析一些出错的 html。
- 注意检查文件长度，和文件头对比。 response.headers.get("Content-Length"))
- 原子写
- 并行
- 模拟浏览器，用。性能不好。
- 注意设置超时时间，否则会一直卡住。
- 注意偶尔会得到异常数据。检查内容。
- 请求头格式不要传 br 否则 requests 不能自动解压缩。


apt install apt-xapian-index 用来给 提供搜索功能
snap install 



python redis


### java

- spring 全家桶
    - pom.xml（Maven 项目）
- springboot 可以替代 xml
    - 配置文件 application.properties `server.port=8080`
    - 运行 `mvn spring-boot:run`
- Spring MVC
    - 为什么java喜欢用RequestBody接收json数据，而不用RequestParam接收k/v？
    - 分三层，控制器，服务，数据。
- 连接数据库可以用 
    - jdbcTemplate 拼接字符串。
    - mybatis 可以写 sql
    - JPA 是 ORM
- 其他功能
    - 定时任务
    - 缓存
    - 队列，线程池
    - 


```java
import org.springframework.boot.*;
import org.springframework.boot.autoconfigure.*;
import org.springframework.web.bind.annotation.*;

@SpringBootApplication
public class DemoApplication {
        public static void main(String[] args) {
                SpringApplication.run(DemoApplication.class, args);
        }

        @RestController
        class HelloController {
                @GetMapping("/hello")
                public String hello() {
                        return "Hello, Spring Boot (One File, No Maven)!";
                }
        }
}

```


```yaml
version: '3.8'
services:
    mysql:
        image: mysql:8.0
        container_name: mysql
        restart: unless-stopped
        environment:
            MYSQL_ROOT_PASSWORD: your_password
            MYSQL_DATABASE: myapp
            MYSQL_USER: appuser
            MYSQL_PASSWORD: app_password
        ports:
            - "3306:3306"
        volumes:
            - mysql_data:/var/lib/mysql
        command: --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci
volumes:
    mysql_data:
```



### docker
- 启动 `docker run -it ubuntu bash` 用 `--name <container_name>` 指定名称
- 执行命令 `docker exec -it mycontainer bash`
- docker-compose 启动命令 `docker-compose up -d` 可以一次启动多个容器
- 其他工具 清理 `docker-clean`


### MySQL
- 安装 MySQL `sudo apt install -y mysql-server`
	- 配置用户和密码 `ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'root';` 密码比如 `wegWweg82.asdg`
	- 远程访问需要设置密码或新建用户。如果需要还要设置防火墙。
	- 新建用户 `CREATE USER '用户名'@'localhost' IDENTIFIED BY '密码'`
	- 修改密码 `ALTER USER 'test_user'@'%' IDENTIFIED BY 'NewTest@789'`
- 登录 MySQL `sudo mysql -u root -p` 也可以用图形客户端
- 字符编码在 MySQL 中需要手动设置为 utf8mb4
- 主键 `id INT AUTO_INCREMENT PRIMARY KEY`
- 查询的时候注意索引。分页用 where 不要用 offset。
- 客户端工具 mysql-workbench，dbeaver-ce, HeidiSQL, datagrip
- 备份 `mysqldump -u 用户名 -p 数据库名 > backup.sql` 可以设置定时备份 `> /backup/`date +\%F`.sql`
- 主从，读写分离，往往是一写多读，注意同步。分库分表。
	- 使用 mysql 的主从复制（Replication）。
	- 可以在应用层实现，也可以使用中间件。
- 用 docker 
	- 运行容器: `docker run -d --name mysql-dev -p 3306:3306 -e MYSQL_ROOT_PASSWORD=你的密码 -v mysql_data:/var/lib/mysql mysql:8.0`
	- 连接 MySQL: `docker exec -it mysql-dev mysql -u root -p`
- 补充 
	- 早期版本（5.0 之前）的 MySQL 语法很不一样。
	- 不设置外键约束，放到代码中处理。


### redis
- 安装 `sudo apt install redis-server`
- 客户端 `redis-cli`
    - 基本命令 `SET mykey "Hello"` `GET mykey` `EXISTS mykey`
- 最简单的情况是当作可以 k-v 数据库，用来作为缓存，可以设置超时时间。
- 做消息列队无法保证可靠性。
- 案例，秒杀



前端
- jquery
- react
- vue
- 界面库

pip install redis


### python 实现 Web 开发

sqlalchemy
- 连接 sqlite3 `engine = create_engine(f"sqlite:///db.sqlite3")`


```python
from sqlalchemy import create_engine, text

# CREATE USER 'testuser'@'localhost' IDENTIFIED BY 'Test@123456';
# 连接字符串：mysql+pymysql://<用户名>:<密码>@<数据库地址>:<端口>/<数据库名>
# 数据库名为 test_db
engine = create_engine('mysql+pymysql://testuser:Test%40123456@localhost:3306/test_db')


with engine.connect() as conn:
    create_table_sql = """
        CREATE TABLE IF NOT EXISTS user_table (
            id INT AUTO_INCREMENT PRIMARY KEY,
            name VARCHAR(50) NOT NULL,
            age INT,
            email VARCHAR(100) UNIQUE NOT NULL,
            create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
    """
    conn.execute(text(create_table_sql))

    insert_sql1 = text("INSERT INTO user_table (name, age, email) VALUES (:name, :age, :email)")
    conn.execute(insert_sql1, {"name": "张三", "age": 25, "email": "zhangsan@test.com"})
    
    conn.commit()
```

redis


命令行工具 redis-cli 

```python
import redis

# 创建 Redis 连接
r = redis.Redis(host='localhost', port=6379, db=0)

# 设置 Redis 数据
r.set('foo', 'bar')

# 获取 Redis 数据
value = r.get('foo')
print(value.decode('utf-8'))    # 输出 'bar'
```

python 的 web 框架 flask, fastapi，django


消息队列
最简单的实现是线程池。

用于一些超长的任务（视频转换），跨服务的任务（而用RPC），流量有波动的任务（瞬时大量订单）。以及分布式事务、广播。实现异步调用。
消息通知用消息队列用户可以界面上不用等待，让消息提示完成。
结果存数据库，或者推送。
是否有消息放丢失的机制，持久化，确认。

Celery 基于 rabbitmq 或者 redis。RabbitMQ(pika/amqpstorm)则更底层一些。



```bash
sudo apt-get install rabbitmq-server
celery -A tasks worker --loglevel=INFO
```


```python
from celery import Celery

app = Celery('hello', broker='amqp://guest@localhost//')

@app.task
def hello():
    return 'hello world'

if __name__ == '__main__':
    result = hello.delay()
```

```python
from tasks import add
add.delay(4, 4)
```

```python
# 导入 Celery 类
from celery import Celery
import time

# 1. 初始化 Celery 实例
# broker：消息代理（Redis 地址）
# backend：结果存储（Redis 地址）
app = Celery(
    'celery_demo',  # 任务名称（自定义）
    broker='redis://localhost:6379/0',  # Redis 第0个数据库作为消息代理
    backend='redis://localhost:6379/1'  # Redis 第1个数据库存储任务结果
)

# 2. 定义异步任务
@app.task  # 装饰器标记为 Celery 任务
def add(x, y):
    """简单的加法任务，模拟耗时操作"""
    time.sleep(2)  # 模拟任务耗时（比如网络请求、数据处理）
    return x + y

@app.task
def multiply(x, y):
    """乘法任务"""
    time.sleep(1)
    return x * y

# 3. 测试代码（可选，仅用于演示调用方式）
if __name__ == '__main__':
    # 方式1：异步调用任务（非阻塞）
    result1 = add.delay(10, 20)
    result2 = multiply.delay(5, 6)
    
    # 打印任务ID
    print(f"加法任务ID: {result1.id}")
    print(f"乘法任务ID: {result2.id}")
    
    # 方式2：获取任务结果（会阻塞直到任务完成）
    print(f"加法任务结果: {result1.get()}")  # 输出 30
    print(f"乘法任务结果: {result2.get()}")  # 输出 30
```


flask 

只负责 web 页面，数据库使用其他组件。

```python
from flask import Flask, request, jsonify
app = Flask(__name__)
@app.route('/')
def hello():
    return 'Hello World!'

```


steamlit 实现一个简单的数据分析的界面

```python
import streamlit as st
import numpy as np

st.title('Hello World')
st.write('Hello World')
st.markdown('### Hello World')
st.header('Hello World')
st.subheader('Hello World')
st.code('print("Hello World")')
st.latex('$E=mc^2$')
st.image('https://www.python.org/static/community_logos/python-logo-master-v3-TM.png')
st.write(np.random.randn(100, 2))
st.map(np.random.randn(100, 2))
st.button('Click me')
st.checkbox('Check me')
st.radio('Choose a number', [1, 2, 3])
st.selectbox('Choose a number', [1, 2, 3])
st.slider('Choose a number', 0, 10)
st.text_input('Enter your name', '')
st.text_area('Enter your name', '')
st.file_uploader('Upload a file', type=['txt', 'csv'])
st.number_input('Enter a number', 0, 10)
st.time_input('Enter a time', '')
st.date_input('Enter a date', '')
```


### 分布式


一致性
- 分布式锁 redlock-py
- 分布式事务 两阶段提交 (2PC)


分布式事务的实现有多种方案，从易到难主要有：
两阶段提交 (2PC)：强一致性，但性能差、易阻塞
补偿事务 (TCC)：柔性事务，性能好但开发成本高
本地消息表：基于消息队列的最终一致性方案
SAGA 模式：长事务的补偿方案

典型应用场景
跨数据库的事务操作（如订单库扣库存 + 支付库扣余额）；
数据库与消息队列的一致性保证（如下单成功后发送消息通知）；
金融、电商等对数据一致性要求极高的核心业务场景。

两阶段提交 2PC

代码解释
get_db_connection：上下文管理器，确保数据库连接正确关闭
TwoPhaseCommit 类：
prepare 方法：预执行所有操作，不提交，仅验证是否可执行
commit 方法：确认所有操作可执行后，统一提交
rollback 方法：任何环节失败，回滚所有操作
test_distributed_transaction：封装完整的 2PC 流程，处理异常并回滚


```python
import pymysql
from contextlib import contextmanager

# 数据库连接配置
DB_CONFIG1 = {
    'host': 'localhost',
    'user': 'root',
    'password': 'your_password',
    'database': 'db1'
}

DB_CONFIG2 = {
    'host': 'localhost',
    'user': 'root',
    'password': 'your_password',
    'database': 'db2'
}

@contextmanager
def get_db_connection(config):
    """获取数据库连接（上下文管理器）"""
    conn = None
    try:
        conn = pymysql.connect(**config)
        yield conn
    except Exception as e:
        if conn:
            conn.rollback()
        raise e
    finally:
        if conn:
            conn.close()

class TwoPhaseCommit:
    def __init__(self, conn1, conn2):
        self.conn1 = conn1
        self.conn2 = conn2
        self.prepare_success = False

    def prepare(self, amount):
        """第一阶段：准备阶段（预提交）"""
        try:
            # 1. 操作db1：扣减账户1的余额
            cursor1 = self.conn1.cursor()
            cursor1.execute("UPDATE account SET balance = balance - %s WHERE id = 1", (amount,))
            # 不提交，仅预检查

            # 2. 操作db2：增加账户2的余额
            cursor2 = self.conn2.cursor()
            cursor2.execute("UPDATE account SET balance = balance + %s WHERE id = 2", (amount,))
            # 不提交，仅预检查

            # 检查是否都可以提交
            self.prepare_success = True
            print("准备阶段成功，等待提交")
        except Exception as e:
            self.prepare_success = False
            raise Exception(f"准备阶段失败: {e}")

    def commit(self):
        """第二阶段：提交"""
        if not self.prepare_success:
            raise Exception("准备阶段未成功，无法提交")
        
        try:
            self.conn1.commit()
            self.conn2.commit()
            print("提交阶段成功，分布式事务完成")
        except Exception as e:
            # 提交失败，回滚所有操作
            self.conn1.rollback()
            self.conn2.rollback()
            raise Exception(f"提交阶段失败: {e}")

    def rollback(self):
        """回滚所有操作"""
        try:
            self.conn1.rollback()
            self.conn2.rollback()
            print("回滚成功")
        except Exception as e:
            raise Exception(f"回滚失败: {e}")

# 测试分布式事务
def test_distributed_transaction(amount):
    with get_db_connection(DB_CONFIG1) as conn1, get_db_connection(DB_CONFIG2) as conn2:
        # 关闭自动提交
        conn1.autocommit(False)
        conn2.autocommit(False)
        
        tpc = TwoPhaseCommit(conn1, conn2)
        try:
            # 第一阶段：准备
            tpc.prepare(amount)
            # 第二阶段：提交
            tpc.commit()
        except Exception as e:
            # 任何阶段失败，回滚
            tpc.rollback()
            print(f"分布式事务失败: {e}")

# 执行测试（转账100元）
if __name__ == "__main__":
    test_distributed_transaction(100)
```


本地消息表 + 消息队列
代码解释
本地消息表：与业务操作在同一本地事务中，确保消息一定会被保存
消息队列：异步发送消息，执行远程操作
补偿机制：定时扫描未处理的消息，重试发送，保证最终一致性

```python
import pymysql
import redis
import time
from contextlib import contextmanager

# 数据库配置（单库，实际可扩展为多库）
DB_CONFIG = {
    'host': 'localhost',
    'user': 'root',
    'password': 'your_password',
    'database': 'test'
}

# Redis 配置（消息队列）
REDIS_CONFIG = {
    'host': 'localhost',
    'port': 6379,
    'db': 0
}

# 创建本地消息表
def init_message_table():
    with get_db_connection(DB_CONFIG) as conn:
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS local_message (
                id INT AUTO_INCREMENT PRIMARY KEY,
                business_id VARCHAR(64) NOT NULL,
                content JSON NOT NULL,
                status TINYINT DEFAULT 0,  -- 0:待发送 1:已发送 2:已确认
                create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
                update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
            )
        """)
        conn.commit()

@contextmanager
def get_db_connection(config):
    conn = None
    try:
        conn = pymysql.connect(**config)
        yield conn
    finally:
        if conn:
            conn.close()

class LocalMessageTransaction:
    def __init__(self):
        self.redis_client = redis.Redis(**REDIS_CONFIG)
        self.queue_name = "distributed_transaction_queue"

    def save_message(self, conn, business_id, content):
        """保存本地消息（与业务操作在同一事务）"""
        cursor = conn.cursor()
        cursor.execute(
            "INSERT INTO local_message (business_id, content, status) VALUES (%s, %s, 0)",
            (business_id, content)
        )

    def execute_business(self, amount):
        """执行本地业务操作 + 保存消息"""
        business_id = f"transfer_{int(time.time())}"
        content = f'{{"amount": {amount}, "target_account": 2}}'

        with get_db_connection(DB_CONFIG) as conn:
            conn.autocommit(False)
            try:
                # 1. 执行本地业务（扣减余额）
                cursor = conn.cursor()
                cursor.execute("UPDATE account SET balance = balance - %s WHERE id = 1", (amount,))
                
                # 2. 保存本地消息（与业务操作同事务）
                self.save_message(conn, business_id, content)
                
                # 3. 提交本地事务
                conn.commit()
                print("本地业务执行成功，消息已保存")
                
                # 4. 发送消息到队列（即使失败，有补偿机制）
                self.send_message(business_id, content)
            except Exception as e:
                conn.rollback()
                raise Exception(f"本地事务失败: {e}")

    def send_message(self, business_id, content):
        """发送消息到Redis队列"""
        try:
            self.redis_client.lpush(self.queue_name, f"{business_id}:{content}")
            # 更新消息状态为已发送
            with get_db_connection(DB_CONFIG) as conn:
                cursor = conn.cursor()
                cursor.execute(
                    "UPDATE local_message SET status = 1 WHERE business_id = %s",
                    (business_id,)
                )
                conn.commit()
            print(f"消息 {business_id} 发送成功")
        except Exception as e:
            print(f"消息发送失败: {e}")

    def consume_message(self):
        """消费消息，执行远程操作"""
        while True:
            # 阻塞获取消息
            message = self.redis_client.brpop(self.queue_name, timeout=5)
            if not message:
                continue
            
            _, msg = message
            business_id, content = msg.decode().split(":", 1)
            try:
                # 模拟执行远程操作（如更新db2的账户余额）
                print(f"执行远程操作: {content}")
                # 这里可以替换为实际的远程调用逻辑
                
                # 更新消息状态为已确认
                with get_db_connection(DB_CONFIG) as conn:
                    cursor = conn.cursor()
                    cursor.execute(
                        "UPDATE local_message SET status = 2 WHERE business_id = %s",
                        (business_id,)
                    )
                    conn.commit()
                print(f"消息 {business_id} 处理完成")
            except Exception as e:
                # 处理失败，重新入队（或记录异常）
                self.redis_client.lpush(self.queue_name, msg)
                print(f"消息 {business_id} 处理失败，重新入队: {e}")

    def compensate(self):
        """补偿机制：定时重试未发送/处理失败的消息"""
        while True:
            with get_db_connection(DB_CONFIG) as conn:
                cursor = conn.cursor()
                # 查询状态为0（待发送）或1（已发送但未确认）的消息
                cursor.execute("""
                    SELECT business_id, content FROM local_message 
                    WHERE status IN (0, 1) AND update_time < DATE_SUB(NOW(), INTERVAL 5 MINUTE)
                """)
                messages = cursor.fetchall()
                
                for business_id, content in messages:
                    # 重新发送消息
                    self.send_message(business_id, content)
                    print(f"补偿消息 {business_id} 发送成功")
            
            # 每5分钟检查一次
            time.sleep(300)

# 测试代码
if __name__ == "__main__":
    # 初始化消息表
    init_message_table()
    
    # 创建事务实例
    transaction = LocalMessageTransaction()
    
    # 1. 执行本地业务（转账100元）
    transaction.execute_business(100)
    
    # 2. 启动消费者（实际部署为独立进程）
    # import threading
    # consumer_thread = threading.Thread(target=transaction.consume_message)
    # consumer_thread.daemon = True
    # consumer_thread.start()
    
    # 3. 启动补偿机制（实际部署为独立进程）
    # compensate_thread = threading.Thread(target=transaction.compensate)
    # compensate_thread.daemon = True
    # compensate_thread.start()
    
    # 保持主线程运行
    # while True:
    #     time.sleep(1)
```
### 分布式计算

dask
- 代替 pandas `import dask.dataframe as dd` 注意不能原地修改，注意 IO 性能消耗会非常非常大。
- 代替 mapreduce `import dask.bag as db` 可以使用 map 来并行。



### Ruby on Rails 

- 新建 Rails 项目 `rails new myapp` 然后 `cd myapp`
- 初始化数据库 bin/rails db:create
    - 创建数据表/模型 `bin/rails generate model User name:string email:string`
    - 执行数据表修改 `bin/rails db:migrate`
- 启动开发服务器 `bin/rails server`
- 在 Rails 里创建页面，按照：模型 → 路由 → 控制器 → 视图。
    - 创建控制器 `bin/rails generate controller Users`
- 页面支持 CRUD 增查改删 
    - 通常写操作需要用户权限
- 开发工具 JetBrains RubyMine
- 书籍 《Agile Web Development with Rails》
- 其他
    - 修改数据表 `bin/rails generate migration AddAgeAndPhoneToUsers age:integer phone:string`
    - 创建首页 `bin/rails generate controller Home index` 然后设置路由 `root "home#index"`。
- 前端，也可以使用 React
- 示例项目 Mastodon

路由 `config/routes.rb`
```ruby
Rails.application.routes.draw do
    get "users", to: "users#index"
    root "home#index"
end
```

控制器 `app/controllers/users_controller.rb`
```ruby
class UsersController < ApplicationController
    def index
        @users = User.all
    end
end
```

视图模板 `app/views/users/index.html.erb`
```ruby


```

### Python
正则表达式

匹配中文

```python
import regex as re
re.search(r'\p{Han}+',"apple苹果")
```


微调
- Finetune GPT-2 with LoRA https://nn.labml.ai/lora/experiment.html




